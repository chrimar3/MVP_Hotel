/**
 * Service Worker Template - Advanced caching strategies for Hotel Review Generator
 * This file will be processed by Workbox webpack plugin
 */

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { BackgroundSyncPlugin } from 'workbox-background-sync';

// Precache all assets generated by webpack
precacheAndRoute(self.__WB_MANIFEST);

// Clean up any old caches
cleanupOutdatedCaches();

// Cache configuration
const DAY_IN_SECONDS = 24 * 60 * 60;
const WEEK_IN_SECONDS = 7 * DAY_IN_SECONDS;
const MONTH_IN_SECONDS = 30 * DAY_IN_SECONDS;

/**
 * Strategy 1: Application Shell - Cache First with long expiration
 * HTML pages, core JS/CSS files
 */
registerRoute(
  ({ request }) => request.destination === 'document',
  new StaleWhileRevalidate({
    cacheName: 'pages-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: DAY_IN_SECONDS,
        purgeOnQuotaError: true
      })
    ]
  })
);

/**
 * Strategy 2: Static Assets - Cache First with long expiration
 * JS, CSS, and other static assets with versioning
 */
registerRoute(
  ({ request }) =>
    request.destination === 'script' ||
    request.destination === 'style' ||
    request.destination === 'worker',
  new CacheFirst({
    cacheName: 'static-assets',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: MONTH_IN_SECONDS,
        purgeOnQuotaError: true
      })
    ]
  })
);

/**
 * Strategy 3: Images - Cache First with size and age limits
 * Optimized for images with different expiration based on type
 */
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 150,
        maxAgeSeconds: WEEK_IN_SECONDS,
        maxSizeBytes: 50 * 1024 * 1024, // 50 MB
        purgeOnQuotaError: true
      })
    ]
  })
);

/**
 * Strategy 4: Fonts - Cache First with very long expiration
 * Web fonts rarely change and should be cached aggressively
 */
registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: 'fonts-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: MONTH_IN_SECONDS * 12, // 1 year
        purgeOnQuotaError: true
      })
    ]
  })
);

/**
 * Strategy 5: API Requests - Network First with fallback
 * For dynamic content that should be fresh when possible
 */
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    networkTimeoutSeconds: 3,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 5, // 5 minutes
        purgeOnQuotaError: true
      })
    ]
  })
);

/**
 * Strategy 6: Google Fonts - Stale While Revalidate
 * Special handling for Google Fonts API
 */
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: DAY_IN_SECONDS,
        purgeOnQuotaError: true
      })
    ]
  })
);

registerRoute(
  ({ url }) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: MONTH_IN_SECONDS * 12, // 1 year
        purgeOnQuotaError: true
      })
    ]
  })
);

/**
 * Background Sync for Analytics and Error Reporting
 * Queue failed requests for retry when online
 */
const bgSyncPlugin = new BackgroundSyncPlugin('analytics-queue', {
  maxRetentionTime: 24 * 60 // 24 hours
});

registerRoute(
  ({ url }) => url.pathname.includes('/analytics') || url.pathname.includes('/errors'),
  new NetworkFirst({
    cacheName: 'analytics-cache',
    networkTimeoutSeconds: 5,
    plugins: [bgSyncPlugin]
  })
);

/**
 * Offline fallbacks
 * Serve cached content when network fails
 */
const offlineHandler = async ({ event }) => {
  if (event.request.destination === 'document') {
    return caches.match('/offline.html') || caches.match('/');
  }

  if (event.request.destination === 'image') {
    return caches.match('/images/offline-placeholder.svg');
  }

  return Response.error();
};

// Register offline fallback
registerRoute(
  ({ event }) => event.request.method === 'GET',
  offlineHandler,
  'GET'
);

/**
 * Advanced caching for NLG modules
 * Cache dynamically imported modules
 */
registerRoute(
  ({ url }) => url.pathname.includes('/js/nlg-engine/') || url.pathname.includes('/security/'),
  new StaleWhileRevalidate({
    cacheName: 'dynamic-modules',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: WEEK_IN_SECONDS,
        purgeOnQuotaError: true
      })
    ]
  })
);

/**
 * Performance optimization: Preload critical resources
 */
self.addEventListener('message', event => {
  if (event.data && event.data.type === 'PRELOAD_RESOURCES') {
    const resources = event.data.resources || [];

    resources.forEach(async resource => {
      try {
        const cache = await caches.open('preload-cache');
        const response = await fetch(resource);
        if (response.ok) {
          await cache.put(resource, response);
        }
      } catch (error) {
        console.warn(`Failed to preload resource: ${resource}`, error);
      }
    });
  }
});

/**
 * Cache management and cleanup
 */
self.addEventListener('message', event => {
  if (event.data && event.data.type === 'CLEAR_CACHE') {
    const cacheName = event.data.cacheName;

    if (cacheName) {
      caches.delete(cacheName).then(() => {
        event.ports[0].postMessage({ success: true });
      });
    } else {
      // Clear all caches except precache
      caches.keys().then(cacheNames => {
        return Promise.all(
          cacheNames
            .filter(name => !name.includes('precache'))
            .map(name => caches.delete(name))
        );
      }).then(() => {
        event.ports[0].postMessage({ success: true });
      });
    }
  }
});

/**
 * Performance monitoring in service worker
 */
self.addEventListener('fetch', event => {
  const startTime = Date.now();

  event.respondWith(
    fetch(event.request)
      .then(response => {
        const endTime = Date.now();
        const duration = endTime - startTime;

        // Report slow requests
        if (duration > 1000) {
          self.clients.matchAll().then(clients => {
            clients.forEach(client => {
              client.postMessage({
                type: 'SLOW_REQUEST',
                url: event.request.url,
                duration
              });
            });
          });
        }

        return response;
      })
      .catch(error => {
        // Handle network errors
        console.warn('Network error in service worker:', error);
        throw error;
      })
  );
});

/**
 * Update notification
 */
self.addEventListener('message', event => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

self.addEventListener('install', event => {
  console.log('Service Worker installing...');
  self.skipWaiting();
});

self.addEventListener('activate', event => {
  console.log('Service Worker activating...');
  event.waitUntil(self.clients.claim());
});

/**
 * Push notification handling (for future features)
 */
self.addEventListener('push', event => {
  if (event.data) {
    const data = event.data.json();
    const options = {
      body: data.body,
      icon: '/icons/icon-192x192.png',
      badge: '/icons/badge-72x72.png',
      vibrate: [100, 50, 100],
      data: {
        dateOfArrival: Date.now(),
        primaryKey: data.primaryKey
      },
      actions: [
        {
          action: 'explore',
          title: 'View Details',
          icon: '/icons/checkmark.png'
        },
        {
          action: 'close',
          title: 'Close',
          icon: '/icons/xmark.png'
        }
      ]
    };

    event.waitUntil(
      self.registration.showNotification(data.title, options)
    );
  }
});

self.addEventListener('notificationclick', event => {
  event.notification.close();

  if (event.action === 'explore') {
    event.waitUntil(
      self.clients.openWindow('/review-generator')
    );
  }
});