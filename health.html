<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Health Check</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
            max-width: 800px;
            width: 100%;
        }
        
        h1 {
            color: #333;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .health-check {
            display: grid;
            gap: 15px;
        }
        
        .check-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: #f8f9fa;
            border-radius: 10px;
            transition: all 0.3s ease;
        }
        
        .check-item:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .check-name {
            font-weight: 600;
            color: #495057;
        }
        
        .check-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }
        
        .status-ok {
            background: #d4edda;
            color: #155724;
        }
        
        .status-warning {
            background: #fff3cd;
            color: #856404;
        }
        
        .status-error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .status-checking {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .metric {
            text-align: center;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .metric-value {
            font-size: 32px;
            font-weight: bold;
            color: #667eea;
        }
        
        .metric-label {
            margin-top: 5px;
            color: #6c757d;
            font-size: 14px;
        }
        
        .timestamp {
            text-align: center;
            margin-top: 30px;
            color: #6c757d;
            font-size: 14px;
        }
        
        .refresh-btn {
            display: block;
            margin: 30px auto 0;
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .refresh-btn:hover {
            transform: scale(1.05);
        }
        
        .refresh-btn:active {
            transform: scale(0.98);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üè• System Health Check</h1>
        
        <div class="health-check" id="healthChecks">
            <!-- Health checks will be populated here -->
        </div>
        
        <div class="metrics" id="metrics">
            <!-- Metrics will be populated here -->
        </div>
        
        <button class="refresh-btn" onclick="runHealthCheck()">Refresh Health Check</button>
        
        <div class="timestamp" id="timestamp"></div>
    </div>
    
    <script>
        class HealthChecker {
            constructor() {
                this.checks = [];
                this.metrics = {};
            }
            
            async runAllChecks() {
                const results = [];
                
                // 1. Check localStorage availability
                results.push(await this.checkLocalStorage());
                
                // 2. Check Service Worker
                results.push(await this.checkServiceWorker());
                
                // 3. Check Network connectivity
                results.push(await this.checkNetwork());
                
                // 4. Check JavaScript execution
                results.push(await this.checkJavaScript());
                
                // 5. Check Browser compatibility
                results.push(await this.checkBrowserCompat());
                
                // 6. Check Performance metrics
                results.push(await this.checkPerformance());
                
                // 7. Check Analytics
                results.push(await this.checkAnalytics());
                
                // 8. Check Memory usage
                results.push(await this.checkMemory());
                
                return results;
            }
            
            async checkLocalStorage() {
                try {
                    const testKey = 'health_check_test';
                    localStorage.setItem(testKey, 'test');
                    localStorage.removeItem(testKey);
                    
                    // Calculate localStorage usage
                    let totalSize = 0;
                    for (let key in localStorage) {
                        totalSize += localStorage[key].length + key.length;
                    }
                    this.metrics.storageUsed = (totalSize / 1024).toFixed(2) + ' KB';
                    
                    return {
                        name: 'LocalStorage',
                        status: 'ok',
                        message: 'Available and functioning'
                    };
                } catch (e) {
                    return {
                        name: 'LocalStorage',
                        status: 'error',
                        message: 'Not available'
                    };
                }
            }
            
            async checkServiceWorker() {
                if ('serviceWorker' in navigator) {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    if (registrations.length > 0) {
                        return {
                            name: 'Service Worker',
                            status: 'ok',
                            message: 'Registered and active'
                        };
                    }
                    return {
                        name: 'Service Worker',
                        status: 'warning',
                        message: 'Available but not registered'
                    };
                }
                return {
                    name: 'Service Worker',
                    status: 'warning',
                    message: 'Not supported'
                };
            }
            
            async checkNetwork() {
                const online = navigator.onLine;
                
                // Try to fetch a small resource
                try {
                    const start = performance.now();
                    await fetch(window.location.origin, { method: 'HEAD', cache: 'no-cache' });
                    const latency = Math.round(performance.now() - start);
                    this.metrics.latency = latency + ' ms';
                    
                    return {
                        name: 'Network',
                        status: 'ok',
                        message: `Online (${latency}ms latency)`
                    };
                } catch {
                    return {
                        name: 'Network',
                        status: online ? 'warning' : 'error',
                        message: online ? 'Online but connectivity issues' : 'Offline'
                    };
                }
            }
            
            async checkJavaScript() {
                try {
                    // Test various JS features
                    const tests = {
                        'Promise': typeof Promise !== 'undefined',
                        'Async/Await': (async () => true)() instanceof Promise,
                        'Fetch API': typeof fetch !== 'undefined',
                        'LocalStorage': typeof localStorage !== 'undefined'
                    };
                    
                    const failed = Object.entries(tests).filter(([_, pass]) => !pass);
                    
                    if (failed.length === 0) {
                        return {
                            name: 'JavaScript',
                            status: 'ok',
                            message: 'All features supported'
                        };
                    }
                    
                    return {
                        name: 'JavaScript',
                        status: 'warning',
                        message: `Missing: ${failed.map(f => f[0]).join(', ')}`
                    };
                } catch {
                    return {
                        name: 'JavaScript',
                        status: 'error',
                        message: 'Execution error'
                    };
                }
            }
            
            async checkBrowserCompat() {
                const userAgent = navigator.userAgent;
                const isModern = 
                    !userAgent.includes('MSIE') &&
                    !userAgent.includes('Trident') &&
                    'IntersectionObserver' in window &&
                    'ResizeObserver' in window;
                
                return {
                    name: 'Browser Compatibility',
                    status: isModern ? 'ok' : 'warning',
                    message: isModern ? 'Modern browser detected' : 'Legacy browser - some features may not work'
                };
            }
            
            async checkPerformance() {
                if (window.performance && performance.timing) {
                    const timing = performance.timing;
                    const loadTime = timing.loadEventEnd - timing.navigationStart;
                    this.metrics.pageLoad = loadTime + ' ms';
                    
                    const status = loadTime < 2000 ? 'ok' : loadTime < 4000 ? 'warning' : 'error';
                    
                    return {
                        name: 'Performance',
                        status,
                        message: `Page load: ${loadTime}ms`
                    };
                }
                
                return {
                    name: 'Performance',
                    status: 'warning',
                    message: 'Performance API not available'
                };
            }
            
            async checkAnalytics() {
                const hasGtag = typeof gtag !== 'undefined';
                const hasGA = typeof ga !== 'undefined';
                
                if (hasGtag || hasGA) {
                    return {
                        name: 'Analytics',
                        status: 'ok',
                        message: 'Google Analytics loaded'
                    };
                }
                
                return {
                    name: 'Analytics',
                    status: 'warning',
                    message: 'Analytics not loaded'
                };
            }
            
            async checkMemory() {
                if (performance.memory) {
                    const used = Math.round(performance.memory.usedJSHeapSize / 1048576);
                    const limit = Math.round(performance.memory.jsHeapSizeLimit / 1048576);
                    const percentage = Math.round((used / limit) * 100);
                    
                    this.metrics.memoryUsed = used + ' MB';
                    this.metrics.memoryLimit = limit + ' MB';
                    
                    const status = percentage < 50 ? 'ok' : percentage < 80 ? 'warning' : 'error';
                    
                    return {
                        name: 'Memory Usage',
                        status,
                        message: `${used}MB / ${limit}MB (${percentage}%)`
                    };
                }
                
                return {
                    name: 'Memory Usage',
                    status: 'warning',
                    message: 'Memory API not available'
                };
            }
            
            getSystemInfo() {
                return {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    language: navigator.language,
                    cookiesEnabled: navigator.cookieEnabled,
                    onLine: navigator.onLine,
                    screenResolution: `${screen.width}x${screen.height}`,
                    viewport: `${window.innerWidth}x${window.innerHeight}`,
                    devicePixelRatio: window.devicePixelRatio
                };
            }
        }
        
        const healthChecker = new HealthChecker();
        
        async function runHealthCheck() {
            const checksContainer = document.getElementById('healthChecks');
            const metricsContainer = document.getElementById('metrics');
            const timestampEl = document.getElementById('timestamp');
            
            // Clear previous results
            checksContainer.innerHTML = '<div class="check-item"><span class="check-name">Running health checks...</span><span class="check-status status-checking">CHECKING</span></div>';
            metricsContainer.innerHTML = '';
            
            // Run checks
            const results = await healthChecker.runAllChecks();
            
            // Display results
            checksContainer.innerHTML = results.map(check => `
                <div class="check-item">
                    <span class="check-name">${check.name}</span>
                    <span class="check-status status-${check.status}">${check.status.toUpperCase()}</span>
                </div>
            `).join('');
            
            // Display metrics
            const metrics = healthChecker.metrics;
            metricsContainer.innerHTML = `
                <div class="metric">
                    <div class="metric-value">${metrics.pageLoad || 'N/A'}</div>
                    <div class="metric-label">Page Load Time</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${metrics.latency || 'N/A'}</div>
                    <div class="metric-label">Network Latency</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${metrics.memoryUsed || 'N/A'}</div>
                    <div class="metric-label">Memory Used</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${metrics.storageUsed || 'N/A'}</div>
                    <div class="metric-label">Storage Used</div>
                </div>
            `;
            
            // Update timestamp
            timestampEl.textContent = `Last checked: ${new Date().toLocaleString()}`;
            
            // Return JSON for monitoring endpoints
            return {
                status: results.every(r => r.status !== 'error') ? 'healthy' : 'unhealthy',
                checks: results,
                metrics: metrics,
                systemInfo: healthChecker.getSystemInfo(),
                timestamp: new Date().toISOString()
            };
        }
        
        // Auto-run on page load
        window.addEventListener('load', runHealthCheck);
        
        // Auto-refresh every 30 seconds
        setInterval(runHealthCheck, 30000);
        
        // Expose for external monitoring
        window.getHealthStatus = runHealthCheck;
    </script>
</body>
</html>