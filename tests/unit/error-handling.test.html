<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error Handling Tests - Hotel Review Generator</title>
    <style>
        body { font-family: system-ui; margin: 20px; line-height: 1.6; }
        .test-suite { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 8px; }
        .test-case { margin: 10px 0; padding: 10px; border-radius: 4px; }
        .pass { background: #d4edda; border-left: 4px solid #28a745; }
        .fail { background: #f8d7da; border-left: 4px solid #dc3545; }
        .pending { background: #fff3cd; border-left: 4px solid #ffc107; }
        .error-details { font-family: monospace; font-size: 0.9em; margin-top: 5px; }
        h2 { color: #495057; border-bottom: 2px solid #e9ecef; padding-bottom: 5px; }
        .summary { background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>ðŸ§ª Error Handling Test Suite</h1>
    <div class="summary">
        <strong>TDD Phase:</strong> Writing failing tests first, then implementing fixes
    </div>
    
    <div id="test-results"></div>

    <script>
        /**
         * Test Suite for Error Handling and Validation
         * Following TDD principles from CLAUDE.md
         */
        class TestSuite {
            constructor() {
                this.tests = [];
                this.results = [];
            }

            /**
             * Add test case following Arrange-Act-Assert pattern
             */
            test(description, testFn) {
                this.tests.push({ description, testFn });
            }

            /**
             * Run all tests and display results
             */
            async runAll() {
                const resultsContainer = document.getElementById('test-results');
                resultsContainer.innerHTML = '';

                for (const { description, testFn } of this.tests) {
                    try {
                        const result = await testFn();
                        this.addResult(description, 'pass', result.message || 'Test passed');
                    } catch (error) {
                        this.addResult(description, 'fail', error.message);
                    }
                }

                this.displaySummary();
            }

            addResult(description, status, message) {
                this.results.push({ description, status, message });
                
                const resultsContainer = document.getElementById('test-results');
                const testDiv = document.createElement('div');
                testDiv.className = `test-case ${status}`;
                testDiv.innerHTML = `
                    <strong>${status.toUpperCase()}:</strong> ${description}
                    <div class="error-details">${message}</div>
                `;
                resultsContainer.appendChild(testDiv);
            }

            displaySummary() {
                const passed = this.results.filter(r => r.status === 'pass').length;
                const failed = this.results.filter(r => r.status === 'fail').length;
                
                const summaryDiv = document.createElement('div');
                summaryDiv.className = 'summary';
                summaryDiv.innerHTML = `
                    <h3>Test Summary</h3>
                    <p><strong>Total:</strong> ${this.results.length} | 
                       <strong>Passed:</strong> ${passed} | 
                       <strong>Failed:</strong> ${failed}</p>
                    <p><strong>Coverage:</strong> Error handling, input validation, boundary conditions</p>
                `;
                
                document.getElementById('test-results').appendChild(summaryDiv);
            }
        }

        // Initialize test suite
        const suite = new TestSuite();

        // Error Handling Tests (These will FAIL initially - TDD approach)
        suite.test('Should handle missing DOM elements gracefully', () => {
            // Arrange: Simulate missing DOM element
            const originalGetElementById = document.getElementById;
            document.getElementById = () => null;
            
            // Act & Assert: Should not throw error
            try {
                // This will fail until we implement proper error handling
                const result = UIController.init();
                return { message: 'Handled missing DOM elements correctly' };
            } catch (error) {
                throw new Error('Failed to handle missing DOM elements: ' + error.message);
            } finally {
                document.getElementById = originalGetElementById;
            }
        });

        suite.test('Should validate staff name input length', () => {
            // Arrange: Create mock input with excessive length
            const mockInput = { value: 'A'.repeat(200) }; // 200 chars
            
            // Act & Assert: Should reject overly long input
            if (!ValidationUtils.validateStaffName) {
                throw new Error('ValidationUtils.validateStaffName not implemented');
            }
            
            const isValid = ValidationUtils.validateStaffName(mockInput.value);
            if (isValid) {
                throw new Error('Should reject staff names longer than 100 characters');
            }
            
            return { message: 'Staff name validation working correctly' };
        });

        suite.test('Should sanitize user input for XSS prevention', () => {
            // Arrange: Malicious input
            const maliciousInput = '<script>alert("xss")</script>';
            
            // Act & Assert: Should sanitize input
            if (!ValidationUtils.sanitizeInput) {
                throw new Error('ValidationUtils.sanitizeInput not implemented');
            }
            
            const sanitized = ValidationUtils.sanitizeInput(maliciousInput);
            if (sanitized.includes('<script>')) {
                throw new Error('Failed to sanitize XSS attempt');
            }
            
            return { message: 'XSS sanitization working correctly' };
        });

        suite.test('Should handle clipboard API failures gracefully', () => {
            // Arrange: Mock failed clipboard API
            const originalClipboard = navigator.clipboard;
            navigator.clipboard = {
                writeText: () => Promise.reject(new Error('Clipboard access denied'))
            };
            
            // Act & Assert: Should fallback gracefully
            try {
                if (!ClipboardManager.copyWithErrorHandling) {
                    throw new Error('ClipboardManager.copyWithErrorHandling not implemented');
                }
                
                ClipboardManager.copyWithErrorHandling('test text');
                return { message: 'Clipboard fallback working correctly' };
            } catch (error) {
                throw new Error('Failed to handle clipboard errors: ' + error.message);
            } finally {
                navigator.clipboard = originalClipboard;
            }
        });

        suite.test('Should validate minimum aspect selection', () => {
            // Arrange: No aspects selected
            const mockCheckboxes = [];
            
            // Act & Assert: Should require at least one aspect
            if (!ValidationUtils.validateAspectsSelection) {
                throw new Error('ValidationUtils.validateAspectsSelection not implemented');
            }
            
            const isValid = ValidationUtils.validateAspectsSelection(mockCheckboxes);
            if (isValid) {
                throw new Error('Should require at least one aspect to be selected');
            }
            
            return { message: 'Aspect selection validation working correctly' };
        });

        suite.test('Should handle network failures for platform routing', () => {
            // Arrange: Simulate network failure
            const mockErrorResponse = () => Promise.reject(new Error('Network error'));
            
            // Act & Assert: Should provide offline functionality
            if (!BookingDetector.getSourceWithErrorHandling) {
                throw new Error('BookingDetector.getSourceWithErrorHandling not implemented');
            }
            
            try {
                const source = BookingDetector.getSourceWithErrorHandling();
                return { message: 'Network error handling working correctly' };
            } catch (error) {
                throw new Error('Failed to handle network errors gracefully');
            }
        });

        suite.test('Should validate comments length and content', () => {
            // Arrange: Test various comment scenarios
            const scenarios = [
                { input: '', shouldPass: true, description: 'empty comments' },
                { input: 'A'.repeat(1000), shouldPass: false, description: 'overly long comments' },
                { input: 'Normal comment', shouldPass: true, description: 'normal comments' }
            ];
            
            if (!ValidationUtils.validateComments) {
                throw new Error('ValidationUtils.validateComments not implemented');
            }
            
            for (const scenario of scenarios) {
                const isValid = ValidationUtils.validateComments(scenario.input);
                if (isValid !== scenario.shouldPass) {
                    throw new Error(`Failed to validate ${scenario.description} correctly`);
                }
            }
            
            return { message: 'Comments validation working for all scenarios' };
        });

        suite.test('Should handle malformed URL parameters', () => {
            // Arrange: Mock malformed URL
            const originalLocation = window.location;
            Object.defineProperty(window, 'location', {
                value: { search: '?source=invalid%20value&other=malicious<script>' },
                writable: true
            });
            
            // Act & Assert: Should handle gracefully
            if (!BookingDetector.getSourceSafely) {
                throw new Error('BookingDetector.getSourceSafely not implemented');
            }
            
            try {
                const source = BookingDetector.getSourceSafely();
                if (!source || source.includes('<script>')) {
                    throw new Error('Failed to handle malformed URL parameters safely');
                }
                return { message: 'URL parameter validation working correctly' };
            } finally {
                Object.defineProperty(window, 'location', {
                    value: originalLocation,
                    writable: true
                });
            }
        });

        // Run tests when page loads
        document.addEventListener('DOMContentLoaded', () => {
            suite.runAll();
        });

        // Global error handler for uncaught errors
        window.addEventListener('error', (event) => {
            console.error('Uncaught error during testing:', event.error);
        });
    </script>
</body>
</html>